# 队列系统说明

## 🎯 设计目标

**用户需求**：
> 不管多少并发，都可以一个一个回复，时间是最不缺的，可以慢回复

**核心原则**：
- ✅ 严格串行处理
- ✅ 支持任意并发
- ✅ 确保稳定可靠
- ✅ 速度不重要

---

## 📊 队列机制

### 1. 串行处理流程

```
请求1 → [队列] → 处理中 → 完成 → 等待2秒 → 请求2
请求2 ──────┘
请求3 ──────────────────────────────────────┘
```

### 2. 队列状态

```
状态1: 空闲
  - queueLength: 0
  - processing: false
  - message: "队列空闲"

状态2: 处理中
  - queueLength: 3
  - processing: true
  - message: "正在处理，剩余 3 个讨论"

状态3: 等待中
  - queueLength: 5
  - processing: false
  - message: "队列中有 5 个讨论等待处理"
```

---

## ✅ 优化功能

### 1. 去重机制

**问题**: 同一讨论可能被多次触发
**解决**:
```javascript
// 检查是否在队列中
if (this.queue.includes(discussionId)) {
  console.log('⏭️  已在队列中，跳过');
  return;
}

// 检查是否已处理
if (this.processed.has(discussionId)) {
  console.log('⏭️  已处理过，跳过');
  return;
}
```

### 2. 处理间隔

**问题**: 连续处理导致资源紧张
**解决**:
```javascript
// 每个讨论处理完后等待2秒
await new Promise(resolve => setTimeout(resolve, 2000));
```

### 3. 错误恢复

**问题**: 单个失败影响整个队列
**解决**:
```javascript
try {
  await processor.processDiscussion(discussionId);
} catch (error) {
  // 从已处理集合移除，允许重试
  this.processed.delete(discussionId);
  // 继续处理下一个
}
```

### 4. 内存管理

**问题**: 已处理集合无限增长
**解决**:
```javascript
// 只保留最近100个
if (this.processed.size > 100) {
  const entries = Array.from(this.processed);
  this.processed = new Set(entries.slice(-100));
}
```

---

## 🔍 队列状态查询

### API端点
```
GET /health
```

### 响应示例
```json
{
  "status": "ok",
  "service": "laya-ask-ai-service",
  "timestamp": "2026-02-27T17:45:00.000Z",
  "queue": {
    "length": 3,
    "processing": true,
    "processedCount": 15,
    "message": "正在处理，剩余 3 个讨论"
  }
}
```

---

## 📊 性能指标

### 单次处理时间
- MCP搜索: 30-60秒
- AI生成: 60-180秒
- 数据库写入: 1-5秒
- **总计**: 2-4分钟/讨论

### 队列吞吐量
```
1个讨论: 2-4分钟
10个讨论: 20-40分钟（串行处理）
100个讨论: 3.3-6.6小时（串行处理）
```

### 并发支持
```
理论上: 无限并发
实际上: 取决于服务器内存和数据库连接
推荐: 每小时不超过20个新讨论
```

---

## 🎯 使用场景

### 场景1: 正常使用
```
用户发帖 → Webhook触发 → 加入队列 → 串行处理 → AI回复
处理时间: 2-4分钟
```

### 场景2: 快速连续发帖
```
用户10秒内发5个帖
→ 5个请求同时到达
→ 全部加入队列
→ 串行处理：帖1(4分钟) → 帖2(4分钟) → ...
→ 总耗时: 20分钟
→ 所有帖子都回复，不会丢失
```

### 场景3: 服务器重启
```
服务器崩溃重启
→ 队列清空（未持久化）
→ 但已处理的记录在processed集合中
→ Webhook重新触发时检查processed集合
→ 避免重复处理
```

---

## ⚠️ 注意事项

### 1. 队列不持久化
**问题**: 服务器重启会丢失队列
**影响**: 未处理的讨论需要等待Webhook重新触发
**解决**:
- FoF Webhooks会自动重试
- 用户可以手动回复触发重新处理

### 2. 已处理集合不持久化
**问题**: 服务器重启后丢失已处理记录
**影响**: 可能重复处理（但不严重，AI会跳过已有回复）
**解决**:
- AI会检查是否已有回复
- 可以添加数据库持久化

### 3. 处理间隔固定
**当前**: 每个讨论处理完等待2秒
**可调整**: 根据实际情况修改 `setTimeout(resolve, 2000)`

---

## 🚀 优化建议

### 短期
- ✅ 已实现：严格串行处理
- ✅ 已实现：去重机制
- ✅ 已实现：错误恢复

### 长期
- 📋 队列持久化（Redis/数据库）
- 📋 优先级队列（VIP用户优先）
- 📋 处理失败自动重试
- 📋 队列管理界面

---

## 📝 总结

**当前队列系统特点**：
- ✅ 严格串行，一个一个处理
- ✅ 支持任意并发请求
- ✅ 不会因并发崩溃
- ✅ 自动去重，避免重复
- ✅ 错误恢复，单个失败不影响整体
- ✅ 处理间隔，避免资源紧张
- ⚠️  队列不持久化（服务器重启丢失）

**适用场景**：
- 论坛自动回复（时间不敏感）
- 任务队列处理（稳定第一）
- 并发请求处理（串行保证）

**承诺**：
> 不管多少并发，都可以一个一个回复，时间是最不缺的，可以慢回复

---

**Commit**: `b15e86c`
**状态**: ✅ 已实施
**服务器**: 准备重启
